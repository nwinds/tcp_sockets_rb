require 'socket'
require 'openssl'

def main
	# TCP server
	server  =TCPServer.new(4481)

	# SSL 
	ctx = OpenSSL::SSL::SSLContext.new
	ctx.cert, ctx.key = create_self_signed_cert(
		1024,
		[['CN', 'localhost']],
		'Generated by Ruby/OpenSSL')
	ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER

	# create SSL wrapper for TCP server
	ssl_server = OpenSSL::SSL::SSLServer.new(server, ctx)

	# accept connection on SSL socket
	connection = ssl_server.accept

	# handle connection
	connection.write('Bah now')
	connection.close
end


# code from webrick/ssl
# generate a self-signed ssl cert for Context
def create_self_signed_cert(bits, cn, comment)
	rsa = OpenSSL::PKey::RSA.new(bits){|p,n|
		case p
		when 0; $stderr.putc "." # BN_generate_prime
		when 1; $stderr.putc "+" # BN_generate_prime
		when 2; $stderr.putc "*" # search good prime,
			# n = #of try,
			# data came from BN_generate_prime too
		when 3; $stderr.putc "\n" # found good prime, n == 0 - p, n == 1 - q,
			# data came from BN_generate_prime too
		else;   $stderr.putc "*" # BN_generate_prime
		end
	}
	cert = OpenSSL::X509::Certificate.new
	cert.version = 2
	cert.serial = 1
	name = OpenSSL::X509::Name.new(cn)
	cert.subject = name
	cert.issuer = name
	cert.not_before = Time.now
	cert.not_after = Time.now + (365 * 24 * 60 * 60)
	cert.public_key = rsa.public_key

	ef = OpenSSL::X509::ExtensionFactory.new(nil, cert)
	ef.issuer_certificate = cert
	cert.extensions = [
		ef.create_extension('basicConstraints', 'CA:FALSE'),
		ef.create_extension('keyUsage', 'keyEncipherment'),
		ef.create_extension('subjectKeyIdentifier', 'hash'),
		ef.create_extension('extendedKeyUsage', 'serverAuth'),
		ef.create_extension('nsComment', comment),
	]
	aki = ef.create_extension('authorityKeyIdentifier', 'keyid:always, issuer:always')
	cert.add_extension(aki)
	cert.sign(rsa, OpenSSL::Digest::SHA1.new)

	return [ cert, rsa ]
end

main
